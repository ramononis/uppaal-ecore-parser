/*
 * generated by Xtext 2.16.0
 */
package nl.utwente.ewi.fmt.uppaalSMC.parser.serializer;

import com.google.inject.Inject;
import java.util.Set;
import nl.utwente.ewi.fmt.uppaalSMC.ChanceEdge;
import nl.utwente.ewi.fmt.uppaalSMC.ChanceNode;
import nl.utwente.ewi.fmt.uppaalSMC.ExponentialLocation;
import nl.utwente.ewi.fmt.uppaalSMC.NSTA;
import nl.utwente.ewi.fmt.uppaalSMC.UppaalSMCPackage;
import nl.utwente.ewi.fmt.uppaalSMC.parser.services.UppaalSMCGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.muml.uppaal.declarations.ArrayInitializer;
import org.muml.uppaal.declarations.ChannelVariableDeclaration;
import org.muml.uppaal.declarations.ClockVariableDeclaration;
import org.muml.uppaal.declarations.DataVariableDeclaration;
import org.muml.uppaal.declarations.DeclarationsPackage;
import org.muml.uppaal.declarations.ExpressionInitializer;
import org.muml.uppaal.declarations.Function;
import org.muml.uppaal.declarations.FunctionDeclaration;
import org.muml.uppaal.declarations.GlobalDeclarations;
import org.muml.uppaal.declarations.LocalDeclarations;
import org.muml.uppaal.declarations.SystemDeclarations;
import org.muml.uppaal.declarations.TypeDeclaration;
import org.muml.uppaal.declarations.TypeIndex;
import org.muml.uppaal.declarations.ValueIndex;
import org.muml.uppaal.declarations.Variable;
import org.muml.uppaal.declarations.global.ChannelList;
import org.muml.uppaal.declarations.global.ChannelPriority;
import org.muml.uppaal.declarations.global.DefaultChannelPriority;
import org.muml.uppaal.declarations.global.GlobalPackage;
import org.muml.uppaal.declarations.system.InstantiationList;
import org.muml.uppaal.declarations.system.ProgressMeasure;
import org.muml.uppaal.declarations.system.SystemPackage;
import org.muml.uppaal.declarations.system.TemplateDeclaration;
import org.muml.uppaal.expressions.ArithmeticExpression;
import org.muml.uppaal.expressions.AssignmentExpression;
import org.muml.uppaal.expressions.BitShiftExpression;
import org.muml.uppaal.expressions.BitwiseExpression;
import org.muml.uppaal.expressions.CompareExpression;
import org.muml.uppaal.expressions.ConditionExpression;
import org.muml.uppaal.expressions.ExpressionsPackage;
import org.muml.uppaal.expressions.FunctionCallExpression;
import org.muml.uppaal.expressions.IdentifierExpression;
import org.muml.uppaal.expressions.LiteralExpression;
import org.muml.uppaal.expressions.LogicalExpression;
import org.muml.uppaal.expressions.MinMaxExpression;
import org.muml.uppaal.expressions.MinusExpression;
import org.muml.uppaal.expressions.NegationExpression;
import org.muml.uppaal.expressions.PlusExpression;
import org.muml.uppaal.expressions.PostIncrementDecrementExpression;
import org.muml.uppaal.expressions.PreIncrementDecrementExpression;
import org.muml.uppaal.expressions.QuantificationExpression;
import org.muml.uppaal.expressions.ScopedIdentifierExpression;
import org.muml.uppaal.statements.Block;
import org.muml.uppaal.statements.DoWhileLoop;
import org.muml.uppaal.statements.EmptyStatement;
import org.muml.uppaal.statements.ExpressionStatement;
import org.muml.uppaal.statements.ForLoop;
import org.muml.uppaal.statements.IfStatement;
import org.muml.uppaal.statements.Iteration;
import org.muml.uppaal.statements.ReturnStatement;
import org.muml.uppaal.statements.StatementsPackage;
import org.muml.uppaal.statements.WhileLoop;
import org.muml.uppaal.templates.Edge;
import org.muml.uppaal.templates.Location;
import org.muml.uppaal.templates.RedefinedTemplate;
import org.muml.uppaal.templates.Selection;
import org.muml.uppaal.templates.Synchronization;
import org.muml.uppaal.templates.Template;
import org.muml.uppaal.templates.TemplatesPackage;
import org.muml.uppaal.types.DeclaredType;
import org.muml.uppaal.types.IntegerBounds;
import org.muml.uppaal.types.RangeTypeSpecification;
import org.muml.uppaal.types.ScalarTypeSpecification;
import org.muml.uppaal.types.StructTypeSpecification;
import org.muml.uppaal.types.TypeReference;
import org.muml.uppaal.types.TypesPackage;
import org.muml.uppaal.visuals.Point;
import org.muml.uppaal.visuals.VisualsPackage;

@SuppressWarnings("all")
public class UppaalSMCSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UppaalSMCGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DeclarationsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DeclarationsPackage.ARRAY_INITIALIZER:
				sequence_ArrayInitializer(context, (ArrayInitializer) semanticObject); 
				return; 
			case DeclarationsPackage.CHANNEL_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getChannelVariableDeclarationRule()) {
					sequence_ChannelVariableDeclaration(context, (ChannelVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParamVariableDeclarationRule()
						|| rule == grammarAccess.getParamChannelVariableDeclarationRule()) {
					sequence_ParamChannelVariableDeclaration(context, (ChannelVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParamRefVariableDeclarationRule()
						|| rule == grammarAccess.getParamRefChannelVariableDeclarationRule()) {
					sequence_ParamRefChannelVariableDeclaration(context, (ChannelVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case DeclarationsPackage.CLOCK_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getClockVariableDeclarationRule()) {
					sequence_ClockVariableDeclaration(context, (ClockVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParamVariableDeclarationRule()
						|| rule == grammarAccess.getParamClockVariableDeclarationRule()) {
					sequence_ParamClockVariableDeclaration(context, (ClockVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParamRefVariableDeclarationRule()
						|| rule == grammarAccess.getParamRefClockVariableDeclarationRule()) {
					sequence_ParamRefClockVariableDeclaration(context, (ClockVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case DeclarationsPackage.DATA_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getDataVariableDeclarationRule()) {
					sequence_DataVariableDeclaration(context, (DataVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParamVariableDeclarationRule()
						|| rule == grammarAccess.getParamDataVariableDeclarationRule()) {
					sequence_ParamDataVariableDeclaration(context, (DataVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParamRefVariableDeclarationRule()
						|| rule == grammarAccess.getParamRefDataVariableDeclarationRule()) {
					sequence_ParamRefDataVariableDeclaration(context, (DataVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case DeclarationsPackage.EXPRESSION_INITIALIZER:
				sequence_ExpressionInitializer(context, (ExpressionInitializer) semanticObject); 
				return; 
			case DeclarationsPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case DeclarationsPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case DeclarationsPackage.GLOBAL_DECLARATIONS:
				sequence_GlobalDeclarations(context, (GlobalDeclarations) semanticObject); 
				return; 
			case DeclarationsPackage.LOCAL_DECLARATIONS:
				if (rule == grammarAccess.getLocalDeclarationsRule()) {
					sequence_LocalDeclarations(context, (LocalDeclarations) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocalNonXmlDeclarationsRule()) {
					sequence_LocalNonXmlDeclarations(context, (LocalDeclarations) semanticObject); 
					return; 
				}
				else break;
			case DeclarationsPackage.PARAMETER:
				sequence_Parameter(context, (org.muml.uppaal.declarations.Parameter) semanticObject); 
				return; 
			case DeclarationsPackage.SYSTEM_DECLARATIONS:
				sequence_SystemDeclarations(context, (SystemDeclarations) semanticObject); 
				return; 
			case DeclarationsPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case DeclarationsPackage.TYPE_INDEX:
				sequence_TypeIndex(context, (TypeIndex) semanticObject); 
				return; 
			case DeclarationsPackage.VALUE_INDEX:
				sequence_ValueIndex(context, (ValueIndex) semanticObject); 
				return; 
			case DeclarationsPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.ARITHMETIC_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getQuantificationExpressionRRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| action == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getConditionExpressionRule()
						|| action == grammarAccess.getConditionExpressionAccess().getConditionExpressionIfExpressionAction_1_0()
						|| rule == grammarAccess.getLogicalOrImpliesExpressionRule()
						|| action == grammarAccess.getLogicalOrImpliesExpressionAccess().getLogicalExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getLogicalAndExpressionRule()
						|| action == grammarAccess.getLogicalAndExpressionAccess().getLogicalExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getInclusiveOrExpressionRule()
						|| action == grammarAccess.getInclusiveOrExpressionAccess().getBitwiseExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getExclusiveOrExpressionRule()
						|| action == grammarAccess.getExclusiveOrExpressionAccess().getBitwiseExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBitwiseExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getCompareExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getCompareExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getMinMaxExpressionRule()
						|| action == grammarAccess.getMinMaxExpressionAccess().getMinMaxExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getBitShiftExpressionRule()
						|| action == grammarAccess.getBitShiftExpressionAccess().getBitShiftExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getArithmeticExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getArithmeticExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()
						|| action == grammarAccess.getPostfixExpressionAccess().getScopedIdentifierExpressionScopeAction_1_0_0()
						|| action == grammarAccess.getPostfixExpressionAccess().getPostIncrementDecrementExpressionExpressionAction_1_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_AdditiveExpression_MultiplicativeExpression(context, (ArithmeticExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRatioExpressionRule()) {
					sequence_RatioExpression(context, (ArithmeticExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionsPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BIT_SHIFT_EXPRESSION:
				sequence_BitShiftExpression(context, (BitShiftExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BITWISE_EXPRESSION:
				sequence_AndExpression_ExclusiveOrExpression_InclusiveOrExpression(context, (BitwiseExpression) semanticObject); 
				return; 
			case ExpressionsPackage.COMPARE_EXPRESSION:
				sequence_EqualityExpression_RelationalExpression(context, (CompareExpression) semanticObject); 
				return; 
			case ExpressionsPackage.CONDITION_EXPRESSION:
				sequence_ConditionExpression(context, (ConditionExpression) semanticObject); 
				return; 
			case ExpressionsPackage.FUNCTION_CALL_EXPRESSION:
				sequence_FunctionCallExpression(context, (FunctionCallExpression) semanticObject); 
				return; 
			case ExpressionsPackage.IDENTIFIER_EXPRESSION:
				sequence_IdentifierExpression(context, (IdentifierExpression) semanticObject); 
				return; 
			case ExpressionsPackage.LITERAL_EXPRESSION:
				sequence_PrimaryExpression(context, (LiteralExpression) semanticObject); 
				return; 
			case ExpressionsPackage.LOGICAL_EXPRESSION:
				sequence_LogicalAndExpression_LogicalOrImpliesExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case ExpressionsPackage.MIN_MAX_EXPRESSION:
				sequence_MinMaxExpression(context, (MinMaxExpression) semanticObject); 
				return; 
			case ExpressionsPackage.MINUS_EXPRESSION:
				sequence_MinusExpression(context, (MinusExpression) semanticObject); 
				return; 
			case ExpressionsPackage.NEGATION_EXPRESSION:
				sequence_NegationExpression(context, (NegationExpression) semanticObject); 
				return; 
			case ExpressionsPackage.PLUS_EXPRESSION:
				sequence_PlusExpression(context, (PlusExpression) semanticObject); 
				return; 
			case ExpressionsPackage.POST_INCREMENT_DECREMENT_EXPRESSION:
				sequence_PostfixExpression(context, (PostIncrementDecrementExpression) semanticObject); 
				return; 
			case ExpressionsPackage.PRE_INCREMENT_DECREMENT_EXPRESSION:
				sequence_PreIncrementDecrementExpression(context, (PreIncrementDecrementExpression) semanticObject); 
				return; 
			case ExpressionsPackage.QUANTIFICATION_EXPRESSION:
				sequence_QuantificationExpression(context, (QuantificationExpression) semanticObject); 
				return; 
			case ExpressionsPackage.SCOPED_IDENTIFIER_EXPRESSION:
				sequence_PostfixExpression(context, (ScopedIdentifierExpression) semanticObject); 
				return; 
			}
		else if (epackage == GlobalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GlobalPackage.CHANNEL_LIST:
				sequence_ChannelList(context, (ChannelList) semanticObject); 
				return; 
			case GlobalPackage.CHANNEL_PRIORITY:
				sequence_ChannelPriority(context, (ChannelPriority) semanticObject); 
				return; 
			case GlobalPackage.DEFAULT_CHANNEL_PRIORITY:
				sequence_DefaultChannelPriority(context, (DefaultChannelPriority) semanticObject); 
				return; 
			}
		else if (epackage == StatementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatementsPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case StatementsPackage.DO_WHILE_LOOP:
				sequence_DoWhileLoop(context, (DoWhileLoop) semanticObject); 
				return; 
			case StatementsPackage.EMPTY_STATEMENT:
				sequence_EmptyStatement(context, (EmptyStatement) semanticObject); 
				return; 
			case StatementsPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case StatementsPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case StatementsPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case StatementsPackage.ITERATION:
				sequence_Iteration(context, (Iteration) semanticObject); 
				return; 
			case StatementsPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case StatementsPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		else if (epackage == SystemPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SystemPackage.INSTANTIATION_LIST:
				sequence_InstantiationList(context, (InstantiationList) semanticObject); 
				return; 
			case SystemPackage.PROGRESS_MEASURE:
				sequence_ProgressMeasure(context, (ProgressMeasure) semanticObject); 
				return; 
			case SystemPackage.SYSTEM:
				sequence_System(context, (org.muml.uppaal.declarations.system.System) semanticObject); 
				return; 
			case SystemPackage.TEMPLATE_DECLARATION:
				sequence_TemplateDeclaration(context, (TemplateDeclaration) semanticObject); 
				return; 
			}
		else if (epackage == TemplatesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TemplatesPackage.EDGE:
				sequence_NEdge(context, (Edge) semanticObject); 
				return; 
			case TemplatesPackage.LOCATION:
				sequence_NLocation(context, (Location) semanticObject); 
				return; 
			case TemplatesPackage.REDEFINED_TEMPLATE:
				sequence_RedefinedTemplate(context, (RedefinedTemplate) semanticObject); 
				return; 
			case TemplatesPackage.SELECTION:
				sequence_Selection(context, (Selection) semanticObject); 
				return; 
			case TemplatesPackage.SYNCHRONIZATION:
				sequence_Synchronization(context, (Synchronization) semanticObject); 
				return; 
			case TemplatesPackage.TEMPLATE:
				sequence_Template(context, (Template) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.DECLARED_TYPE:
				sequence_DeclaredType(context, (DeclaredType) semanticObject); 
				return; 
			case TypesPackage.INTEGER_BOUNDS:
				sequence_IntegerBounds(context, (IntegerBounds) semanticObject); 
				return; 
			case TypesPackage.RANGE_TYPE_SPECIFICATION:
				sequence_RangeTypeSpecification(context, (RangeTypeSpecification) semanticObject); 
				return; 
			case TypesPackage.SCALAR_TYPE_SPECIFICATION:
				sequence_ScalarTypeSpecification(context, (ScalarTypeSpecification) semanticObject); 
				return; 
			case TypesPackage.STRUCT_TYPE_SPECIFICATION:
				sequence_StructTypeSpecification(context, (StructTypeSpecification) semanticObject); 
				return; 
			case TypesPackage.TYPE_REFERENCE:
				if (rule == grammarAccess.getChannelTypeReferenceRule()) {
					sequence_ChannelTypeReference(context, (TypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClockTypeReferenceRule()) {
					sequence_ClockTypeReference(context, (TypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeDefinitionRule()
						|| rule == grammarAccess.getTypeReferenceRule()) {
					sequence_TypeReference(context, (TypeReference) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == UppaalSMCPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UppaalSMCPackage.CHANCE_EDGE:
				sequence_CEdge(context, (ChanceEdge) semanticObject); 
				return; 
			case UppaalSMCPackage.CHANCE_NODE:
				sequence_BranchPoint(context, (ChanceNode) semanticObject); 
				return; 
			case UppaalSMCPackage.EXPONENTIAL_LOCATION:
				sequence_ELocation(context, (ExponentialLocation) semanticObject); 
				return; 
			case UppaalSMCPackage.NSTA:
				sequence_NSTA(context, (NSTA) semanticObject); 
				return; 
			}
		else if (epackage == VisualsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VisualsPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns ArithmeticExpression
	 *     QuantificationExpressionR returns ArithmeticExpression
	 *     AssignmentExpression returns ArithmeticExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns ArithmeticExpression
	 *     ConditionExpression returns ArithmeticExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns ArithmeticExpression
	 *     LogicalOrImpliesExpression returns ArithmeticExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns ArithmeticExpression
	 *     LogicalAndExpression returns ArithmeticExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns ArithmeticExpression
	 *     InclusiveOrExpression returns ArithmeticExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns ArithmeticExpression
	 *     ExclusiveOrExpression returns ArithmeticExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns ArithmeticExpression
	 *     AndExpression returns ArithmeticExpression
	 *     AndExpression.BitwiseExpression_1_0 returns ArithmeticExpression
	 *     EqualityExpression returns ArithmeticExpression
	 *     EqualityExpression.CompareExpression_1_0 returns ArithmeticExpression
	 *     RelationalExpression returns ArithmeticExpression
	 *     RelationalExpression.CompareExpression_1_0 returns ArithmeticExpression
	 *     MinMaxExpression returns ArithmeticExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns ArithmeticExpression
	 *     BitShiftExpression returns ArithmeticExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns ArithmeticExpression
	 *     AdditiveExpression returns ArithmeticExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     MultiplicativeExpression returns ArithmeticExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     UnaryExpression returns ArithmeticExpression
	 *     PostfixExpression returns ArithmeticExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns ArithmeticExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns ArithmeticExpression
	 *     PrimaryExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         (firstExpr=AdditiveExpression_ArithmeticExpression_1_0 operator=AdditiveOperator secondExpr=MultiplicativeExpression) | 
	 *         (firstExpr=MultiplicativeExpression_ArithmeticExpression_1_0 operator=MultiplicativeOperator secondExpr=UnaryExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitwiseExpression
	 *     QuantificationExpressionR returns BitwiseExpression
	 *     AssignmentExpression returns BitwiseExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns BitwiseExpression
	 *     ConditionExpression returns BitwiseExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns BitwiseExpression
	 *     LogicalOrImpliesExpression returns BitwiseExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns BitwiseExpression
	 *     LogicalAndExpression returns BitwiseExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns BitwiseExpression
	 *     InclusiveOrExpression returns BitwiseExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns BitwiseExpression
	 *     ExclusiveOrExpression returns BitwiseExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns BitwiseExpression
	 *     AndExpression returns BitwiseExpression
	 *     AndExpression.BitwiseExpression_1_0 returns BitwiseExpression
	 *     EqualityExpression returns BitwiseExpression
	 *     EqualityExpression.CompareExpression_1_0 returns BitwiseExpression
	 *     RelationalExpression returns BitwiseExpression
	 *     RelationalExpression.CompareExpression_1_0 returns BitwiseExpression
	 *     MinMaxExpression returns BitwiseExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns BitwiseExpression
	 *     BitShiftExpression returns BitwiseExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns BitwiseExpression
	 *     AdditiveExpression returns BitwiseExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns BitwiseExpression
	 *     MultiplicativeExpression returns BitwiseExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns BitwiseExpression
	 *     UnaryExpression returns BitwiseExpression
	 *     PostfixExpression returns BitwiseExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns BitwiseExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns BitwiseExpression
	 *     PrimaryExpression returns BitwiseExpression
	 *
	 * Constraint:
	 *     (
	 *         (firstExpr=InclusiveOrExpression_BitwiseExpression_1_0 operator=BitwiseOrOperator secondExpr=ExclusiveOrExpression) | 
	 *         (firstExpr=ExclusiveOrExpression_BitwiseExpression_1_0 operator=BitwiseXorOperator secondExpr=AndExpression) | 
	 *         (firstExpr=AndExpression_BitwiseExpression_1_0 operator=BitwiseAndOperator secondExpr=EqualityExpression)
	 *     )
	 */
	protected void sequence_AndExpression_ExclusiveOrExpression_InclusiveOrExpression(ISerializationContext context, BitwiseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initializer returns ArrayInitializer
	 *     ArrayInitializer returns ArrayInitializer
	 *
	 * Constraint:
	 *     (initializer+=Initializer initializer+=Initializer*)
	 */
	protected void sequence_ArrayInitializer(ISerializationContext context, ArrayInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AssignmentExpression
	 *     QuantificationExpressionR returns AssignmentExpression
	 *     AssignmentExpression returns AssignmentExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns AssignmentExpression
	 *     ConditionExpression returns AssignmentExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns AssignmentExpression
	 *     LogicalOrImpliesExpression returns AssignmentExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns AssignmentExpression
	 *     LogicalAndExpression returns AssignmentExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns AssignmentExpression
	 *     InclusiveOrExpression returns AssignmentExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns AssignmentExpression
	 *     ExclusiveOrExpression returns AssignmentExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns AssignmentExpression
	 *     AndExpression returns AssignmentExpression
	 *     AndExpression.BitwiseExpression_1_0 returns AssignmentExpression
	 *     EqualityExpression returns AssignmentExpression
	 *     EqualityExpression.CompareExpression_1_0 returns AssignmentExpression
	 *     RelationalExpression returns AssignmentExpression
	 *     RelationalExpression.CompareExpression_1_0 returns AssignmentExpression
	 *     MinMaxExpression returns AssignmentExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns AssignmentExpression
	 *     BitShiftExpression returns AssignmentExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns AssignmentExpression
	 *     AdditiveExpression returns AssignmentExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns AssignmentExpression
	 *     MultiplicativeExpression returns AssignmentExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns AssignmentExpression
	 *     UnaryExpression returns AssignmentExpression
	 *     PostfixExpression returns AssignmentExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns AssignmentExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns AssignmentExpression
	 *     PrimaryExpression returns AssignmentExpression
	 *
	 * Constraint:
	 *     (firstExpr=AssignmentExpression_AssignmentExpression_1_0 operator=AssignmentOperator secondExpr=AssignmentExpression)
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.ASSIGNMENT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.ASSIGNMENT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionFirstExprAction_1_0(), semanticObject.getFirstExpr());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getOperatorAssignmentOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getSecondExprAssignmentExpressionParserRuleCall_1_2_0(), semanticObject.getSecondExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitShiftExpression
	 *     QuantificationExpressionR returns BitShiftExpression
	 *     AssignmentExpression returns BitShiftExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns BitShiftExpression
	 *     ConditionExpression returns BitShiftExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns BitShiftExpression
	 *     LogicalOrImpliesExpression returns BitShiftExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns BitShiftExpression
	 *     LogicalAndExpression returns BitShiftExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns BitShiftExpression
	 *     InclusiveOrExpression returns BitShiftExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns BitShiftExpression
	 *     ExclusiveOrExpression returns BitShiftExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns BitShiftExpression
	 *     AndExpression returns BitShiftExpression
	 *     AndExpression.BitwiseExpression_1_0 returns BitShiftExpression
	 *     EqualityExpression returns BitShiftExpression
	 *     EqualityExpression.CompareExpression_1_0 returns BitShiftExpression
	 *     RelationalExpression returns BitShiftExpression
	 *     RelationalExpression.CompareExpression_1_0 returns BitShiftExpression
	 *     MinMaxExpression returns BitShiftExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns BitShiftExpression
	 *     BitShiftExpression returns BitShiftExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns BitShiftExpression
	 *     AdditiveExpression returns BitShiftExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns BitShiftExpression
	 *     MultiplicativeExpression returns BitShiftExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns BitShiftExpression
	 *     UnaryExpression returns BitShiftExpression
	 *     PostfixExpression returns BitShiftExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns BitShiftExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns BitShiftExpression
	 *     PrimaryExpression returns BitShiftExpression
	 *
	 * Constraint:
	 *     (firstExpr=BitShiftExpression_BitShiftExpression_1_0 operator=BitShiftOperator secondExpr=AdditiveExpression)
	 */
	protected void sequence_BitShiftExpression(ISerializationContext context, BitShiftExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BIT_SHIFT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BIT_SHIFT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitShiftExpressionAccess().getBitShiftExpressionFirstExprAction_1_0(), semanticObject.getFirstExpr());
		feeder.accept(grammarAccess.getBitShiftExpressionAccess().getOperatorBitShiftOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBitShiftExpressionAccess().getSecondExprAdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getSecondExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *     Statement returns Block
	 *
	 * Constraint:
	 *     (declarations=LocalNonXmlDeclarations statement+=Statement*)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Location returns ChanceNode
	 *     BranchPoint returns ChanceNode
	 *
	 * Constraint:
	 *     (name=STRING position=Point? (color=ColorKind | colorCode=STRING)?)
	 */
	protected void sequence_BranchPoint(ISerializationContext context, ChanceNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Edge returns ChanceEdge
	 *     CEdge returns ChanceEdge
	 *
	 * Constraint:
	 *     (
	 *         (color=ColorKind | colorCode=STRING)? 
	 *         source=[Location|STRING] 
	 *         target=[Location|STRING] 
	 *         (selection+=Selection selection+=Selection*)? 
	 *         guard=Expression? 
	 *         synchronization=Synchronization? 
	 *         (update+=Expression update+=Expression*)? 
	 *         weight=Expression 
	 *         bendPoint+=Point*
	 *     )
	 */
	protected void sequence_CEdge(ISerializationContext context, ChanceEdge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChannelPriorityItem returns ChannelList
	 *     ChannelList returns ChannelList
	 *
	 * Constraint:
	 *     (channelExpression+=IdentifierExpression channelExpression+=IdentifierExpression*)
	 */
	protected void sequence_ChannelList(ISerializationContext context, ChannelList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChannelPriority returns ChannelPriority
	 *
	 * Constraint:
	 *     (item+=ChannelPriorityItem item+=ChannelPriorityItem*)
	 */
	protected void sequence_ChannelPriority(ISerializationContext context, ChannelPriority semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChannelTypeReference returns TypeReference
	 *
	 * Constraint:
	 *     referredType=[Type|CHAN]
	 */
	protected void sequence_ChannelTypeReference(ISerializationContext context, TypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChannelTypeReferenceAccess().getReferredTypeTypeCHANTerminalRuleCall_0_1(), semanticObject.eGet(TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns ChannelVariableDeclaration
	 *     VariableDeclaration returns ChannelVariableDeclaration
	 *     ChannelVariableDeclaration returns ChannelVariableDeclaration
	 *
	 * Constraint:
	 *     ((urgent?='urgent' | broadcast?='broadcast')* typeDefinition=ChannelTypeReference variable+=Variable variable+=Variable*)
	 */
	protected void sequence_ChannelVariableDeclaration(ISerializationContext context, ChannelVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClockTypeReference returns TypeReference
	 *
	 * Constraint:
	 *     referredType=[Type|CLOCK]
	 */
	protected void sequence_ClockTypeReference(ISerializationContext context, TypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClockTypeReferenceAccess().getReferredTypeTypeCLOCKTerminalRuleCall_0_1(), semanticObject.eGet(TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns ClockVariableDeclaration
	 *     VariableDeclaration returns ClockVariableDeclaration
	 *     ClockVariableDeclaration returns ClockVariableDeclaration
	 *
	 * Constraint:
	 *     (typeDefinition=ClockTypeReference variable+=Variable variable+=Variable*)
	 */
	protected void sequence_ClockVariableDeclaration(ISerializationContext context, ClockVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ConditionExpression
	 *     QuantificationExpressionR returns ConditionExpression
	 *     AssignmentExpression returns ConditionExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns ConditionExpression
	 *     ConditionExpression returns ConditionExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns ConditionExpression
	 *     LogicalOrImpliesExpression returns ConditionExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns ConditionExpression
	 *     LogicalAndExpression returns ConditionExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns ConditionExpression
	 *     InclusiveOrExpression returns ConditionExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns ConditionExpression
	 *     ExclusiveOrExpression returns ConditionExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns ConditionExpression
	 *     AndExpression returns ConditionExpression
	 *     AndExpression.BitwiseExpression_1_0 returns ConditionExpression
	 *     EqualityExpression returns ConditionExpression
	 *     EqualityExpression.CompareExpression_1_0 returns ConditionExpression
	 *     RelationalExpression returns ConditionExpression
	 *     RelationalExpression.CompareExpression_1_0 returns ConditionExpression
	 *     MinMaxExpression returns ConditionExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns ConditionExpression
	 *     BitShiftExpression returns ConditionExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns ConditionExpression
	 *     AdditiveExpression returns ConditionExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ConditionExpression
	 *     MultiplicativeExpression returns ConditionExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ConditionExpression
	 *     UnaryExpression returns ConditionExpression
	 *     PostfixExpression returns ConditionExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns ConditionExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns ConditionExpression
	 *     PrimaryExpression returns ConditionExpression
	 *
	 * Constraint:
	 *     (ifExpression=ConditionExpression_ConditionExpression_1_0 thenExpression=Expression elseExpression=ConditionExpression)
	 */
	protected void sequence_ConditionExpression(ISerializationContext context, ConditionExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__IF_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__IF_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__THEN_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__THEN_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__ELSE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__ELSE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionExpressionAccess().getConditionExpressionIfExpressionAction_1_0(), semanticObject.getIfExpression());
		feeder.accept(grammarAccess.getConditionExpressionAccess().getThenExpressionExpressionParserRuleCall_1_2_0(), semanticObject.getThenExpression());
		feeder.accept(grammarAccess.getConditionExpressionAccess().getElseExpressionConditionExpressionParserRuleCall_1_4_0(), semanticObject.getElseExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns DataVariableDeclaration
	 *     VariableDeclaration returns DataVariableDeclaration
	 *     DataVariableDeclaration returns DataVariableDeclaration
	 *
	 * Constraint:
	 *     (prefix=DataVariablePrefix? typeDefinition=TypeDefinition variable+=Variable variable+=Variable*)
	 */
	protected void sequence_DataVariableDeclaration(ISerializationContext context, DataVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredType returns DeclaredType
	 *
	 * Constraint:
	 *     (name=ID index+=Index*)
	 */
	protected void sequence_DeclaredType(ISerializationContext context, DeclaredType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChannelPriorityItem returns DefaultChannelPriority
	 *     DefaultChannelPriority returns DefaultChannelPriority
	 *
	 * Constraint:
	 *     {DefaultChannelPriority}
	 */
	protected void sequence_DefaultChannelPriority(ISerializationContext context, DefaultChannelPriority semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DoWhileLoop
	 *     DoWhileLoop returns DoWhileLoop
	 *
	 * Constraint:
	 *     (statement=Statement expression=Expression)
	 */
	protected void sequence_DoWhileLoop(ISerializationContext context, DoWhileLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.DO_WHILE_LOOP__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.DO_WHILE_LOOP__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.DO_WHILE_LOOP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.DO_WHILE_LOOP__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoWhileLoopAccess().getStatementStatementParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getDoWhileLoopAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Location returns ExponentialLocation
	 *     ELocation returns ExponentialLocation
	 *
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         position=Point? 
	 *         (color=ColorKind | colorCode=STRING)? 
	 *         comment=ID? 
	 *         invariant=Expression? 
	 *         (exitRate=RatioExpression | exitRate=Expression) 
	 *         locationTimeKind=LocationKind?
	 *     )
	 */
	protected void sequence_ELocation(ISerializationContext context, ExponentialLocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns EmptyStatement
	 *     EmptyStatement returns EmptyStatement
	 *
	 * Constraint:
	 *     {EmptyStatement}
	 */
	protected void sequence_EmptyStatement(ISerializationContext context, EmptyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CompareExpression
	 *     QuantificationExpressionR returns CompareExpression
	 *     AssignmentExpression returns CompareExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns CompareExpression
	 *     ConditionExpression returns CompareExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns CompareExpression
	 *     LogicalOrImpliesExpression returns CompareExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns CompareExpression
	 *     LogicalAndExpression returns CompareExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns CompareExpression
	 *     InclusiveOrExpression returns CompareExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns CompareExpression
	 *     ExclusiveOrExpression returns CompareExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns CompareExpression
	 *     AndExpression returns CompareExpression
	 *     AndExpression.BitwiseExpression_1_0 returns CompareExpression
	 *     EqualityExpression returns CompareExpression
	 *     EqualityExpression.CompareExpression_1_0 returns CompareExpression
	 *     RelationalExpression returns CompareExpression
	 *     RelationalExpression.CompareExpression_1_0 returns CompareExpression
	 *     MinMaxExpression returns CompareExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns CompareExpression
	 *     BitShiftExpression returns CompareExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns CompareExpression
	 *     AdditiveExpression returns CompareExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns CompareExpression
	 *     MultiplicativeExpression returns CompareExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns CompareExpression
	 *     UnaryExpression returns CompareExpression
	 *     PostfixExpression returns CompareExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns CompareExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns CompareExpression
	 *     PrimaryExpression returns CompareExpression
	 *
	 * Constraint:
	 *     (
	 *         (firstExpr=EqualityExpression_CompareExpression_1_0 operator=EqualityOperator secondExpr=RelationalExpression) | 
	 *         (firstExpr=RelationalExpression_CompareExpression_1_0 operator=RelationalOperator secondExpr=MinMaxExpression)
	 *     )
	 */
	protected void sequence_EqualityExpression_RelationalExpression(ISerializationContext context, CompareExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initializer returns ExpressionInitializer
	 *     ExpressionInitializer returns ExpressionInitializer
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionInitializer(ISerializationContext context, ExpressionInitializer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeclarationsPackage.Literals.EXPRESSION_INITIALIZER__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeclarationsPackage.Literals.EXPRESSION_INITIALIZER__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionInitializerAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (initialization=Expression condition=Expression iteration=Expression statement=Statement)
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.FOR_LOOP__INITIALIZATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.FOR_LOOP__INITIALIZATION));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.FOR_LOOP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.FOR_LOOP__CONDITION));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.FOR_LOOP__ITERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.FOR_LOOP__ITERATION));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.FOR_LOOP__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.FOR_LOOP__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForLoopAccess().getInitializationExpressionParserRuleCall_2_0(), semanticObject.getInitialization());
		feeder.accept(grammarAccess.getForLoopAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getForLoopAccess().getIterationExpressionParserRuleCall_6_0(), semanticObject.getIteration());
		feeder.accept(grammarAccess.getForLoopAccess().getStatementStatementParserRuleCall_8_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionCallExpression
	 *     QuantificationExpressionR returns FunctionCallExpression
	 *     AssignmentExpression returns FunctionCallExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns FunctionCallExpression
	 *     ConditionExpression returns FunctionCallExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns FunctionCallExpression
	 *     LogicalOrImpliesExpression returns FunctionCallExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns FunctionCallExpression
	 *     LogicalAndExpression returns FunctionCallExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns FunctionCallExpression
	 *     InclusiveOrExpression returns FunctionCallExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns FunctionCallExpression
	 *     ExclusiveOrExpression returns FunctionCallExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns FunctionCallExpression
	 *     AndExpression returns FunctionCallExpression
	 *     AndExpression.BitwiseExpression_1_0 returns FunctionCallExpression
	 *     EqualityExpression returns FunctionCallExpression
	 *     EqualityExpression.CompareExpression_1_0 returns FunctionCallExpression
	 *     RelationalExpression returns FunctionCallExpression
	 *     RelationalExpression.CompareExpression_1_0 returns FunctionCallExpression
	 *     MinMaxExpression returns FunctionCallExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns FunctionCallExpression
	 *     BitShiftExpression returns FunctionCallExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns FunctionCallExpression
	 *     AdditiveExpression returns FunctionCallExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns FunctionCallExpression
	 *     MultiplicativeExpression returns FunctionCallExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns FunctionCallExpression
	 *     UnaryExpression returns FunctionCallExpression
	 *     PostfixExpression returns FunctionCallExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns FunctionCallExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns FunctionCallExpression
	 *     PrimaryExpression returns FunctionCallExpression
	 *     FunctionCallExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=[Function|ID] (argument+=Expression argument+=Expression*)?)
	 */
	protected void sequence_FunctionCallExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns FunctionDeclaration
	 *     FunctionDeclaration returns FunctionDeclaration
	 *
	 * Constraint:
	 *     function=Function
	 */
	protected void sequence_FunctionDeclaration(ISerializationContext context, FunctionDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeclarationsPackage.Literals.FUNCTION_DECLARATION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeclarationsPackage.Literals.FUNCTION_DECLARATION__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionDeclarationAccess().getFunctionFunctionParserRuleCall_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (returnType=TypeDefinition name=ID (parameter+=Parameter parameter+=Parameter*)? block=Block)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalDeclarations returns GlobalDeclarations
	 *
	 * Constraint:
	 *     (declaration+=Declaration* channelPriority=ChannelPriority? declaration+=Declaration*)
	 */
	protected void sequence_GlobalDeclarations(ISerializationContext context, GlobalDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IdentifierExpression
	 *     QuantificationExpressionR returns IdentifierExpression
	 *     AssignmentExpression returns IdentifierExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns IdentifierExpression
	 *     ConditionExpression returns IdentifierExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns IdentifierExpression
	 *     LogicalOrImpliesExpression returns IdentifierExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns IdentifierExpression
	 *     LogicalAndExpression returns IdentifierExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns IdentifierExpression
	 *     InclusiveOrExpression returns IdentifierExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns IdentifierExpression
	 *     ExclusiveOrExpression returns IdentifierExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns IdentifierExpression
	 *     AndExpression returns IdentifierExpression
	 *     AndExpression.BitwiseExpression_1_0 returns IdentifierExpression
	 *     EqualityExpression returns IdentifierExpression
	 *     EqualityExpression.CompareExpression_1_0 returns IdentifierExpression
	 *     RelationalExpression returns IdentifierExpression
	 *     RelationalExpression.CompareExpression_1_0 returns IdentifierExpression
	 *     MinMaxExpression returns IdentifierExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns IdentifierExpression
	 *     BitShiftExpression returns IdentifierExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns IdentifierExpression
	 *     AdditiveExpression returns IdentifierExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns IdentifierExpression
	 *     MultiplicativeExpression returns IdentifierExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns IdentifierExpression
	 *     UnaryExpression returns IdentifierExpression
	 *     PostfixExpression returns IdentifierExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns IdentifierExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns IdentifierExpression
	 *     PrimaryExpression returns IdentifierExpression
	 *     IdentifierExpression returns IdentifierExpression
	 *
	 * Constraint:
	 *     (identifier=[NamedElement|ID] clockRate?='''? (index+=Expression index+=Expression*)?)
	 */
	protected void sequence_IdentifierExpression(ISerializationContext context, IdentifierExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (ifExpression=Expression thenStatement=Statement elseStatement=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InstantiationList returns InstantiationList
	 *
	 * Constraint:
	 *     (template+=[AbstractTemplate|ID] template+=[AbstractTemplate|ID]*)
	 */
	protected void sequence_InstantiationList(ISerializationContext context, InstantiationList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IntegerBounds returns IntegerBounds
	 *
	 * Constraint:
	 *     (lowerBound=Expression upperBound=Expression)
	 */
	protected void sequence_IntegerBounds(ISerializationContext context, IntegerBounds semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.INTEGER_BOUNDS__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.INTEGER_BOUNDS__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.INTEGER_BOUNDS__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.INTEGER_BOUNDS__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerBoundsAccess().getLowerBoundExpressionParserRuleCall_0_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getIntegerBoundsAccess().getUpperBoundExpressionParserRuleCall_2_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Iteration
	 *     Iteration returns Iteration
	 *
	 * Constraint:
	 *     (variable+=Variable typeDefinition=TypeDefinition statement=Statement)
	 */
	protected void sequence_Iteration(ISerializationContext context, Iteration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalDeclarations returns LocalDeclarations
	 *
	 * Constraint:
	 *     declaration+=Declaration*
	 */
	protected void sequence_LocalDeclarations(ISerializationContext context, LocalDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalNonXmlDeclarations returns LocalDeclarations
	 *
	 * Constraint:
	 *     declaration+=Declaration*
	 */
	protected void sequence_LocalNonXmlDeclarations(ISerializationContext context, LocalDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LogicalExpression
	 *     QuantificationExpressionR returns LogicalExpression
	 *     AssignmentExpression returns LogicalExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns LogicalExpression
	 *     ConditionExpression returns LogicalExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns LogicalExpression
	 *     LogicalOrImpliesExpression returns LogicalExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns LogicalExpression
	 *     LogicalAndExpression returns LogicalExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns LogicalExpression
	 *     InclusiveOrExpression returns LogicalExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns LogicalExpression
	 *     ExclusiveOrExpression returns LogicalExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns LogicalExpression
	 *     AndExpression returns LogicalExpression
	 *     AndExpression.BitwiseExpression_1_0 returns LogicalExpression
	 *     EqualityExpression returns LogicalExpression
	 *     EqualityExpression.CompareExpression_1_0 returns LogicalExpression
	 *     RelationalExpression returns LogicalExpression
	 *     RelationalExpression.CompareExpression_1_0 returns LogicalExpression
	 *     MinMaxExpression returns LogicalExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns LogicalExpression
	 *     BitShiftExpression returns LogicalExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns LogicalExpression
	 *     AdditiveExpression returns LogicalExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns LogicalExpression
	 *     MultiplicativeExpression returns LogicalExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns LogicalExpression
	 *     UnaryExpression returns LogicalExpression
	 *     PostfixExpression returns LogicalExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns LogicalExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns LogicalExpression
	 *     PrimaryExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (
	 *         (firstExpr=LogicalOrImpliesExpression_LogicalExpression_1_0 operator=LogicalOrImpliesOperator secondExpr=LogicalAndExpression) | 
	 *         (firstExpr=LogicalAndExpression_LogicalExpression_1_0 operator=LogicalAndOperator secondExpr=InclusiveOrExpression)
	 *     )
	 */
	protected void sequence_LogicalAndExpression_LogicalOrImpliesExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinMaxExpression
	 *     QuantificationExpressionR returns MinMaxExpression
	 *     AssignmentExpression returns MinMaxExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns MinMaxExpression
	 *     ConditionExpression returns MinMaxExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns MinMaxExpression
	 *     LogicalOrImpliesExpression returns MinMaxExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns MinMaxExpression
	 *     LogicalAndExpression returns MinMaxExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns MinMaxExpression
	 *     InclusiveOrExpression returns MinMaxExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns MinMaxExpression
	 *     ExclusiveOrExpression returns MinMaxExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns MinMaxExpression
	 *     AndExpression returns MinMaxExpression
	 *     AndExpression.BitwiseExpression_1_0 returns MinMaxExpression
	 *     EqualityExpression returns MinMaxExpression
	 *     EqualityExpression.CompareExpression_1_0 returns MinMaxExpression
	 *     RelationalExpression returns MinMaxExpression
	 *     RelationalExpression.CompareExpression_1_0 returns MinMaxExpression
	 *     MinMaxExpression returns MinMaxExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns MinMaxExpression
	 *     BitShiftExpression returns MinMaxExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns MinMaxExpression
	 *     AdditiveExpression returns MinMaxExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns MinMaxExpression
	 *     MultiplicativeExpression returns MinMaxExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns MinMaxExpression
	 *     UnaryExpression returns MinMaxExpression
	 *     PostfixExpression returns MinMaxExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns MinMaxExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns MinMaxExpression
	 *     PrimaryExpression returns MinMaxExpression
	 *
	 * Constraint:
	 *     (firstExpr=MinMaxExpression_MinMaxExpression_1_0 operator=MinMaxOperator secondExpr=BitShiftExpression)
	 */
	protected void sequence_MinMaxExpression(ISerializationContext context, MinMaxExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.MIN_MAX_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.MIN_MAX_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getMinMaxExpressionFirstExprAction_1_0(), semanticObject.getFirstExpr());
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getOperatorMinMaxOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getSecondExprBitShiftExpressionParserRuleCall_1_2_0(), semanticObject.getSecondExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinusExpression
	 *     QuantificationExpressionR returns MinusExpression
	 *     AssignmentExpression returns MinusExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns MinusExpression
	 *     ConditionExpression returns MinusExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns MinusExpression
	 *     LogicalOrImpliesExpression returns MinusExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns MinusExpression
	 *     LogicalAndExpression returns MinusExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns MinusExpression
	 *     InclusiveOrExpression returns MinusExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns MinusExpression
	 *     ExclusiveOrExpression returns MinusExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns MinusExpression
	 *     AndExpression returns MinusExpression
	 *     AndExpression.BitwiseExpression_1_0 returns MinusExpression
	 *     EqualityExpression returns MinusExpression
	 *     EqualityExpression.CompareExpression_1_0 returns MinusExpression
	 *     RelationalExpression returns MinusExpression
	 *     RelationalExpression.CompareExpression_1_0 returns MinusExpression
	 *     MinMaxExpression returns MinusExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns MinusExpression
	 *     BitShiftExpression returns MinusExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns MinusExpression
	 *     AdditiveExpression returns MinusExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns MinusExpression
	 *     MultiplicativeExpression returns MinusExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns MinusExpression
	 *     UnaryExpression returns MinusExpression
	 *     MinusExpression returns MinusExpression
	 *     PostfixExpression returns MinusExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns MinusExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns MinusExpression
	 *     PrimaryExpression returns MinusExpression
	 *
	 * Constraint:
	 *     invertedExpression=UnaryExpression
	 */
	protected void sequence_MinusExpression(ISerializationContext context, MinusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.MINUS_EXPRESSION__INVERTED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.MINUS_EXPRESSION__INVERTED_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusExpressionAccess().getInvertedExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getInvertedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Edge returns Edge
	 *     NEdge returns Edge
	 *
	 * Constraint:
	 *     (
	 *         (color=ColorKind | colorCode=STRING)? 
	 *         source=[Location|STRING] 
	 *         target=[Location|STRING] 
	 *         (selection+=Selection selection+=Selection*)? 
	 *         guard=Expression? 
	 *         synchronization=Synchronization? 
	 *         (update+=Expression update+=Expression*)? 
	 *         bendPoint+=Point*
	 *     )
	 */
	protected void sequence_NEdge(ISerializationContext context, Edge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Location returns Location
	 *     NLocation returns Location
	 *
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         position=Point? 
	 *         (color=ColorKind | colorCode=STRING)? 
	 *         comment=ID? 
	 *         invariant=Expression? 
	 *         locationTimeKind=LocationKind?
	 *     )
	 */
	protected void sequence_NLocation(ISerializationContext context, Location semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NSTA returns NSTA
	 *
	 * Constraint:
	 *     (name=ID globalDeclarations=GlobalDeclarations? template+=Template* systemDeclarations=SystemDeclarations)
	 */
	protected void sequence_NSTA(ISerializationContext context, NSTA semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NegationExpression
	 *     QuantificationExpressionR returns NegationExpression
	 *     AssignmentExpression returns NegationExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns NegationExpression
	 *     ConditionExpression returns NegationExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns NegationExpression
	 *     LogicalOrImpliesExpression returns NegationExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns NegationExpression
	 *     LogicalAndExpression returns NegationExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns NegationExpression
	 *     InclusiveOrExpression returns NegationExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns NegationExpression
	 *     ExclusiveOrExpression returns NegationExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns NegationExpression
	 *     AndExpression returns NegationExpression
	 *     AndExpression.BitwiseExpression_1_0 returns NegationExpression
	 *     EqualityExpression returns NegationExpression
	 *     EqualityExpression.CompareExpression_1_0 returns NegationExpression
	 *     RelationalExpression returns NegationExpression
	 *     RelationalExpression.CompareExpression_1_0 returns NegationExpression
	 *     MinMaxExpression returns NegationExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns NegationExpression
	 *     BitShiftExpression returns NegationExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns NegationExpression
	 *     AdditiveExpression returns NegationExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns NegationExpression
	 *     MultiplicativeExpression returns NegationExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns NegationExpression
	 *     UnaryExpression returns NegationExpression
	 *     NegationExpression returns NegationExpression
	 *     PostfixExpression returns NegationExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns NegationExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns NegationExpression
	 *     PrimaryExpression returns NegationExpression
	 *
	 * Constraint:
	 *     negatedExpression=UnaryExpression
	 */
	protected void sequence_NegationExpression(ISerializationContext context, NegationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.NEGATION_EXPRESSION__NEGATED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.NEGATION_EXPRESSION__NEGATED_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationExpressionAccess().getNegatedExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getNegatedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParamVariableDeclaration returns ChannelVariableDeclaration
	 *     ParamChannelVariableDeclaration returns ChannelVariableDeclaration
	 *
	 * Constraint:
	 *     ((urgent?='urgent' | broadcast?='broadcast')* typeDefinition=ChannelTypeReference variable+=Variable)
	 */
	protected void sequence_ParamChannelVariableDeclaration(ISerializationContext context, ChannelVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamVariableDeclaration returns ClockVariableDeclaration
	 *     ParamClockVariableDeclaration returns ClockVariableDeclaration
	 *
	 * Constraint:
	 *     (typeDefinition=ClockTypeReference variable+=Variable)
	 */
	protected void sequence_ParamClockVariableDeclaration(ISerializationContext context, ClockVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamVariableDeclaration returns DataVariableDeclaration
	 *     ParamDataVariableDeclaration returns DataVariableDeclaration
	 *
	 * Constraint:
	 *     (prefix=DataVariablePrefix? typeDefinition=TypeDefinition variable+=Variable)
	 */
	protected void sequence_ParamDataVariableDeclaration(ISerializationContext context, DataVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamRefVariableDeclaration returns ChannelVariableDeclaration
	 *     ParamRefChannelVariableDeclaration returns ChannelVariableDeclaration
	 *
	 * Constraint:
	 *     ((urgent?='urgent' | broadcast?='broadcast')* typeDefinition=ChannelTypeReference variable+=Variable)
	 */
	protected void sequence_ParamRefChannelVariableDeclaration(ISerializationContext context, ChannelVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamRefVariableDeclaration returns ClockVariableDeclaration
	 *     ParamRefClockVariableDeclaration returns ClockVariableDeclaration
	 *
	 * Constraint:
	 *     (typeDefinition=ClockTypeReference variable+=Variable)
	 */
	protected void sequence_ParamRefClockVariableDeclaration(ISerializationContext context, ClockVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamRefVariableDeclaration returns DataVariableDeclaration
	 *     ParamRefDataVariableDeclaration returns DataVariableDeclaration
	 *
	 * Constraint:
	 *     (prefix=DataVariablePrefix? typeDefinition=TypeDefinition variable+=Variable)
	 */
	protected void sequence_ParamRefDataVariableDeclaration(ISerializationContext context, DataVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (variableDeclaration=ParamVariableDeclaration | (variableDeclaration=ParamRefVariableDeclaration callType=CallByReference))
	 */
	protected void sequence_Parameter(ISerializationContext context, org.muml.uppaal.declarations.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PlusExpression
	 *     QuantificationExpressionR returns PlusExpression
	 *     AssignmentExpression returns PlusExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns PlusExpression
	 *     ConditionExpression returns PlusExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns PlusExpression
	 *     LogicalOrImpliesExpression returns PlusExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns PlusExpression
	 *     LogicalAndExpression returns PlusExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns PlusExpression
	 *     InclusiveOrExpression returns PlusExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns PlusExpression
	 *     ExclusiveOrExpression returns PlusExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns PlusExpression
	 *     AndExpression returns PlusExpression
	 *     AndExpression.BitwiseExpression_1_0 returns PlusExpression
	 *     EqualityExpression returns PlusExpression
	 *     EqualityExpression.CompareExpression_1_0 returns PlusExpression
	 *     RelationalExpression returns PlusExpression
	 *     RelationalExpression.CompareExpression_1_0 returns PlusExpression
	 *     MinMaxExpression returns PlusExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns PlusExpression
	 *     BitShiftExpression returns PlusExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns PlusExpression
	 *     AdditiveExpression returns PlusExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns PlusExpression
	 *     MultiplicativeExpression returns PlusExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns PlusExpression
	 *     UnaryExpression returns PlusExpression
	 *     PlusExpression returns PlusExpression
	 *     PostfixExpression returns PlusExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns PlusExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns PlusExpression
	 *     PrimaryExpression returns PlusExpression
	 *
	 * Constraint:
	 *     confirmedExpression=UnaryExpression
	 */
	protected void sequence_PlusExpression(ISerializationContext context, PlusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.PLUS_EXPRESSION__CONFIRMED_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.PLUS_EXPRESSION__CONFIRMED_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusExpressionAccess().getConfirmedExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getConfirmedExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     {Point}
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PostIncrementDecrementExpression
	 *     QuantificationExpressionR returns PostIncrementDecrementExpression
	 *     AssignmentExpression returns PostIncrementDecrementExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns PostIncrementDecrementExpression
	 *     ConditionExpression returns PostIncrementDecrementExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns PostIncrementDecrementExpression
	 *     LogicalOrImpliesExpression returns PostIncrementDecrementExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns PostIncrementDecrementExpression
	 *     LogicalAndExpression returns PostIncrementDecrementExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns PostIncrementDecrementExpression
	 *     InclusiveOrExpression returns PostIncrementDecrementExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns PostIncrementDecrementExpression
	 *     ExclusiveOrExpression returns PostIncrementDecrementExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns PostIncrementDecrementExpression
	 *     AndExpression returns PostIncrementDecrementExpression
	 *     AndExpression.BitwiseExpression_1_0 returns PostIncrementDecrementExpression
	 *     EqualityExpression returns PostIncrementDecrementExpression
	 *     EqualityExpression.CompareExpression_1_0 returns PostIncrementDecrementExpression
	 *     RelationalExpression returns PostIncrementDecrementExpression
	 *     RelationalExpression.CompareExpression_1_0 returns PostIncrementDecrementExpression
	 *     MinMaxExpression returns PostIncrementDecrementExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns PostIncrementDecrementExpression
	 *     BitShiftExpression returns PostIncrementDecrementExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns PostIncrementDecrementExpression
	 *     AdditiveExpression returns PostIncrementDecrementExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns PostIncrementDecrementExpression
	 *     MultiplicativeExpression returns PostIncrementDecrementExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns PostIncrementDecrementExpression
	 *     UnaryExpression returns PostIncrementDecrementExpression
	 *     PostfixExpression returns PostIncrementDecrementExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns PostIncrementDecrementExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns PostIncrementDecrementExpression
	 *     PrimaryExpression returns PostIncrementDecrementExpression
	 *
	 * Constraint:
	 *     (expression=PostfixExpression_PostIncrementDecrementExpression_1_1_0 operator=IncrementDecrementOperator)
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, PostIncrementDecrementExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.POST_INCREMENT_DECREMENT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.POST_INCREMENT_DECREMENT_EXPRESSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.POST_INCREMENT_DECREMENT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.POST_INCREMENT_DECREMENT_EXPRESSION__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfixExpressionAccess().getPostIncrementDecrementExpressionExpressionAction_1_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPostfixExpressionAccess().getOperatorIncrementDecrementOperatorEnumRuleCall_1_1_1_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ScopedIdentifierExpression
	 *     QuantificationExpressionR returns ScopedIdentifierExpression
	 *     AssignmentExpression returns ScopedIdentifierExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns ScopedIdentifierExpression
	 *     ConditionExpression returns ScopedIdentifierExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns ScopedIdentifierExpression
	 *     LogicalOrImpliesExpression returns ScopedIdentifierExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns ScopedIdentifierExpression
	 *     LogicalAndExpression returns ScopedIdentifierExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns ScopedIdentifierExpression
	 *     InclusiveOrExpression returns ScopedIdentifierExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns ScopedIdentifierExpression
	 *     ExclusiveOrExpression returns ScopedIdentifierExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns ScopedIdentifierExpression
	 *     AndExpression returns ScopedIdentifierExpression
	 *     AndExpression.BitwiseExpression_1_0 returns ScopedIdentifierExpression
	 *     EqualityExpression returns ScopedIdentifierExpression
	 *     EqualityExpression.CompareExpression_1_0 returns ScopedIdentifierExpression
	 *     RelationalExpression returns ScopedIdentifierExpression
	 *     RelationalExpression.CompareExpression_1_0 returns ScopedIdentifierExpression
	 *     MinMaxExpression returns ScopedIdentifierExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns ScopedIdentifierExpression
	 *     BitShiftExpression returns ScopedIdentifierExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns ScopedIdentifierExpression
	 *     AdditiveExpression returns ScopedIdentifierExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ScopedIdentifierExpression
	 *     MultiplicativeExpression returns ScopedIdentifierExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ScopedIdentifierExpression
	 *     UnaryExpression returns ScopedIdentifierExpression
	 *     PostfixExpression returns ScopedIdentifierExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns ScopedIdentifierExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns ScopedIdentifierExpression
	 *     PrimaryExpression returns ScopedIdentifierExpression
	 *
	 * Constraint:
	 *     (scope=PostfixExpression_ScopedIdentifierExpression_1_0_0 identifier=IdentifierExpression)
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, ScopedIdentifierExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.SCOPED_IDENTIFIER_EXPRESSION__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.SCOPED_IDENTIFIER_EXPRESSION__SCOPE));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.SCOPED_IDENTIFIER_EXPRESSION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.SCOPED_IDENTIFIER_EXPRESSION__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfixExpressionAccess().getScopedIdentifierExpressionScopeAction_1_0_0(), semanticObject.getScope());
		feeder.accept(grammarAccess.getPostfixExpressionAccess().getIdentifierIdentifierExpressionParserRuleCall_1_0_2_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PreIncrementDecrementExpression
	 *     QuantificationExpressionR returns PreIncrementDecrementExpression
	 *     AssignmentExpression returns PreIncrementDecrementExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns PreIncrementDecrementExpression
	 *     ConditionExpression returns PreIncrementDecrementExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns PreIncrementDecrementExpression
	 *     LogicalOrImpliesExpression returns PreIncrementDecrementExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns PreIncrementDecrementExpression
	 *     LogicalAndExpression returns PreIncrementDecrementExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns PreIncrementDecrementExpression
	 *     InclusiveOrExpression returns PreIncrementDecrementExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns PreIncrementDecrementExpression
	 *     ExclusiveOrExpression returns PreIncrementDecrementExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns PreIncrementDecrementExpression
	 *     AndExpression returns PreIncrementDecrementExpression
	 *     AndExpression.BitwiseExpression_1_0 returns PreIncrementDecrementExpression
	 *     EqualityExpression returns PreIncrementDecrementExpression
	 *     EqualityExpression.CompareExpression_1_0 returns PreIncrementDecrementExpression
	 *     RelationalExpression returns PreIncrementDecrementExpression
	 *     RelationalExpression.CompareExpression_1_0 returns PreIncrementDecrementExpression
	 *     MinMaxExpression returns PreIncrementDecrementExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns PreIncrementDecrementExpression
	 *     BitShiftExpression returns PreIncrementDecrementExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns PreIncrementDecrementExpression
	 *     AdditiveExpression returns PreIncrementDecrementExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns PreIncrementDecrementExpression
	 *     MultiplicativeExpression returns PreIncrementDecrementExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns PreIncrementDecrementExpression
	 *     UnaryExpression returns PreIncrementDecrementExpression
	 *     PostfixExpression returns PreIncrementDecrementExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns PreIncrementDecrementExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns PreIncrementDecrementExpression
	 *     PrimaryExpression returns PreIncrementDecrementExpression
	 *     PreIncrementDecrementExpression returns PreIncrementDecrementExpression
	 *
	 * Constraint:
	 *     (operator=IncrementDecrementOperator expression=UnaryExpression)
	 */
	protected void sequence_PreIncrementDecrementExpression(ISerializationContext context, PreIncrementDecrementExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.PRE_INCREMENT_DECREMENT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.PRE_INCREMENT_DECREMENT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.PRE_INCREMENT_DECREMENT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.PRE_INCREMENT_DECREMENT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreIncrementDecrementExpressionAccess().getOperatorIncrementDecrementOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPreIncrementDecrementExpressionAccess().getExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralExpression
	 *     QuantificationExpressionR returns LiteralExpression
	 *     AssignmentExpression returns LiteralExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns LiteralExpression
	 *     ConditionExpression returns LiteralExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns LiteralExpression
	 *     LogicalOrImpliesExpression returns LiteralExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns LiteralExpression
	 *     LogicalAndExpression returns LiteralExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns LiteralExpression
	 *     InclusiveOrExpression returns LiteralExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns LiteralExpression
	 *     ExclusiveOrExpression returns LiteralExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns LiteralExpression
	 *     AndExpression returns LiteralExpression
	 *     AndExpression.BitwiseExpression_1_0 returns LiteralExpression
	 *     EqualityExpression returns LiteralExpression
	 *     EqualityExpression.CompareExpression_1_0 returns LiteralExpression
	 *     RelationalExpression returns LiteralExpression
	 *     RelationalExpression.CompareExpression_1_0 returns LiteralExpression
	 *     MinMaxExpression returns LiteralExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns LiteralExpression
	 *     BitShiftExpression returns LiteralExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns LiteralExpression
	 *     AdditiveExpression returns LiteralExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns LiteralExpression
	 *     MultiplicativeExpression returns LiteralExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns LiteralExpression
	 *     UnaryExpression returns LiteralExpression
	 *     PostfixExpression returns LiteralExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns LiteralExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns LiteralExpression
	 *     PrimaryExpression returns LiteralExpression
	 *
	 * Constraint:
	 *     (text=STRING | text=INT_STR | text=DOUBLE_STR | text='true' | text='false')
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, LiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgressMeasure returns ProgressMeasure
	 *
	 * Constraint:
	 *     expression+=Expression+
	 */
	protected void sequence_ProgressMeasure(ISerializationContext context, ProgressMeasure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns QuantificationExpression
	 *     QuantificationExpressionR returns QuantificationExpression
	 *     QuantificationExpression returns QuantificationExpression
	 *     AssignmentExpression returns QuantificationExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns QuantificationExpression
	 *     ConditionExpression returns QuantificationExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns QuantificationExpression
	 *     LogicalOrImpliesExpression returns QuantificationExpression
	 *     LogicalOrImpliesExpression.LogicalExpression_1_0 returns QuantificationExpression
	 *     LogicalAndExpression returns QuantificationExpression
	 *     LogicalAndExpression.LogicalExpression_1_0 returns QuantificationExpression
	 *     InclusiveOrExpression returns QuantificationExpression
	 *     InclusiveOrExpression.BitwiseExpression_1_0 returns QuantificationExpression
	 *     ExclusiveOrExpression returns QuantificationExpression
	 *     ExclusiveOrExpression.BitwiseExpression_1_0 returns QuantificationExpression
	 *     AndExpression returns QuantificationExpression
	 *     AndExpression.BitwiseExpression_1_0 returns QuantificationExpression
	 *     EqualityExpression returns QuantificationExpression
	 *     EqualityExpression.CompareExpression_1_0 returns QuantificationExpression
	 *     RelationalExpression returns QuantificationExpression
	 *     RelationalExpression.CompareExpression_1_0 returns QuantificationExpression
	 *     MinMaxExpression returns QuantificationExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns QuantificationExpression
	 *     BitShiftExpression returns QuantificationExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns QuantificationExpression
	 *     AdditiveExpression returns QuantificationExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns QuantificationExpression
	 *     MultiplicativeExpression returns QuantificationExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns QuantificationExpression
	 *     UnaryExpression returns QuantificationExpression
	 *     PostfixExpression returns QuantificationExpression
	 *     PostfixExpression.ScopedIdentifierExpression_1_0_0 returns QuantificationExpression
	 *     PostfixExpression.PostIncrementDecrementExpression_1_1_0 returns QuantificationExpression
	 *     PrimaryExpression returns QuantificationExpression
	 *
	 * Constraint:
	 *     (quantifier=Quantifier variable+=Variable typeDefinition=TypeDefinition expression=Expression)
	 */
	protected void sequence_QuantificationExpression(ISerializationContext context, QuantificationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns RangeTypeSpecification
	 *     RangeTypeSpecification returns RangeTypeSpecification
	 *
	 * Constraint:
	 *     bounds=IntegerBounds
	 */
	protected void sequence_RangeTypeSpecification(ISerializationContext context, RangeTypeSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.RANGE_TYPE_SPECIFICATION__BOUNDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.RANGE_TYPE_SPECIFICATION__BOUNDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeTypeSpecificationAccess().getBoundsIntegerBoundsParserRuleCall_2_0(), semanticObject.getBounds());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RatioExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (firstExpr=AdditiveExpression operator=RatioOperator secondExpr=AdditiveExpression)
	 */
	protected void sequence_RatioExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.ARITHMETIC_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.ARITHMETIC_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRatioExpressionAccess().getFirstExprAdditiveExpressionParserRuleCall_0_0(), semanticObject.getFirstExpr());
		feeder.accept(grammarAccess.getRatioExpressionAccess().getOperatorRatioOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRatioExpressionAccess().getSecondExprAdditiveExpressionParserRuleCall_2_0(), semanticObject.getSecondExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RedefinedTemplate returns RedefinedTemplate
	 *
	 * Constraint:
	 *     (name=ID (parameter+=Parameter parameter+=Parameter*)* referredTemplate=[AbstractTemplate|ID])
	 */
	protected void sequence_RedefinedTemplate(ISerializationContext context, RedefinedTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     returnExpression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns ScalarTypeSpecification
	 *     ScalarTypeSpecification returns ScalarTypeSpecification
	 *
	 * Constraint:
	 *     sizeExpression=Expression
	 */
	protected void sequence_ScalarTypeSpecification(ISerializationContext context, ScalarTypeSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.SCALAR_TYPE_SPECIFICATION__SIZE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.SCALAR_TYPE_SPECIFICATION__SIZE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScalarTypeSpecificationAccess().getSizeExpressionExpressionParserRuleCall_2_0(), semanticObject.getSizeExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Selection returns Selection
	 *
	 * Constraint:
	 *     (variable+=Variable typeDefinition=TypeDefinition)
	 */
	protected void sequence_Selection(ISerializationContext context, Selection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns StructTypeSpecification
	 *     StructTypeSpecification returns StructTypeSpecification
	 *
	 * Constraint:
	 *     declaration+=DataVariableDeclaration*
	 */
	protected void sequence_StructTypeSpecification(ISerializationContext context, StructTypeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Synchronization returns Synchronization
	 *
	 * Constraint:
	 *     (channelExpression=IdentifierExpression kind=SynchronizationKind)
	 */
	protected void sequence_Synchronization(ISerializationContext context, Synchronization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplatesPackage.Literals.SYNCHRONIZATION__CHANNEL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplatesPackage.Literals.SYNCHRONIZATION__CHANNEL_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, TemplatesPackage.Literals.SYNCHRONIZATION__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplatesPackage.Literals.SYNCHRONIZATION__KIND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSynchronizationAccess().getChannelExpressionIdentifierExpressionParserRuleCall_0_0(), semanticObject.getChannelExpression());
		feeder.accept(grammarAccess.getSynchronizationAccess().getKindSynchronizationKindEnumRuleCall_1_0(), semanticObject.getKind());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SystemDeclarations returns SystemDeclarations
	 *
	 * Constraint:
	 *     (declaration+=Declaration* system=System progressMeasure=ProgressMeasure?)
	 */
	protected void sequence_SystemDeclarations(ISerializationContext context, SystemDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (instantiationList+=InstantiationList instantiationList+=InstantiationList*)
	 */
	protected void sequence_System(ISerializationContext context, org.muml.uppaal.declarations.system.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns TemplateDeclaration
	 *     TemplateDeclaration returns TemplateDeclaration
	 *
	 * Constraint:
	 *     (declaredTemplate=RedefinedTemplate (argument+=Expression argument+=Expression*)?)
	 */
	protected void sequence_TemplateDeclaration(ISerializationContext context, TemplateDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Template returns Template
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameter+=Parameter parameter+=Parameter*)? 
	 *         declarations=LocalDeclarations? 
	 *         location+=Location* 
	 *         init=[Location|STRING] 
	 *         edge+=Edge*
	 *     )
	 */
	protected void sequence_Template(ISerializationContext context, Template semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns TypeDeclaration
	 *     TypeDeclaration returns TypeDeclaration
	 *
	 * Constraint:
	 *     (typeDefinition=TypeDefinition type+=DeclaredType type+=DeclaredType*)
	 */
	protected void sequence_TypeDeclaration(ISerializationContext context, TypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Index returns TypeIndex
	 *     TypeIndex returns TypeIndex
	 *
	 * Constraint:
	 *     typeDefinition=TypeDefinition
	 */
	protected void sequence_TypeIndex(ISerializationContext context, TypeIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeclarationsPackage.Literals.TYPE_INDEX__TYPE_DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeclarationsPackage.Literals.TYPE_INDEX__TYPE_DEFINITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeIndexAccess().getTypeDefinitionTypeDefinitionParserRuleCall_1_0(), semanticObject.getTypeDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeDefinition returns TypeReference
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     referredType=[Type|ID]
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeReferenceAccess().getReferredTypeTypeIDTerminalRuleCall_0_1(), semanticObject.eGet(TypesPackage.Literals.TYPE_REFERENCE__REFERRED_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Index returns ValueIndex
	 *     ValueIndex returns ValueIndex
	 *
	 * Constraint:
	 *     sizeExpression=Expression
	 */
	protected void sequence_ValueIndex(ISerializationContext context, ValueIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeclarationsPackage.Literals.VALUE_INDEX__SIZE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeclarationsPackage.Literals.VALUE_INDEX__SIZE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueIndexAccess().getSizeExpressionExpressionParserRuleCall_1_0(), semanticObject.getSizeExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID index+=Index* initializer=Initializer?)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (expression=Expression statement=Statement)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.WHILE_LOOP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.WHILE_LOOP__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.WHILE_LOOP__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.WHILE_LOOP__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileLoopAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhileLoopAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
}
